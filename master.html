<!doctype html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script class="env" src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js"></script>
<script class="env" src="http://strd6.github.io/tempest/javascripts/envweb.js"></script>
<script class="env" src="http://strd6.github.io/require/master.js"></script>
</head>
<body>
<script>
;(function(PACKAGE) {
var require = Require.generateFor(PACKAGE);
require('./main')
})({
  "version": "0.1.1",
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "mode": "100644",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Daniel X Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "mode": "100644",
      "content": "md\n==\n\nGenerate documentation from from literate code files.\n",
      "type": "blob"
    },
    "documenter.coffee.md": {
      "path": "documenter.coffee.md",
      "mode": "100644",
      "content": "Documenter\n==========\n\nThis is a stopgap documenter until we get a nicer one.\n\nIt documents Markdown files using a Github API compatible markdown service.\n\nThe content of our stylesheet for rendering inline.\n\n    style = require \"./style/markdown\"\n\nExport a constructor that when given a markdown service returns a documenter.\n\n    module.exports = (markdownService) ->\n      documenter =\n\nReturns a promise that will be fulfilled with html when the markdown source is \nconverted.\n\n        document: (source) ->\n          markdownService(source)\n\nDocument all source files in a package.\n\n        documentAll: (pkg) ->\n          {entryPoint, source, repository} = pkg\n          {branch, default_branch} = repository\n\n          if branch is default_branch\n            base = \"docs\"\n          else\n            base = \"#{branch}/docs\"\n\n          documentableFiles = Object.keys(source).select (name) ->\n            name.extension() is \"md\"\n          \n          promises = documentableFiles.map (name) ->\n            documenter.document source[name].content\n          \n          Deferred.when(promises).then (results) ->\n            index = []\n\n            results.map (result, i) ->\n              # Assuming .*.md so we should strip the extension twice\n              name = documentableFiles[i].withoutExtension().withoutExtension()\n              \n              content = documenter.template name, result.first()\n              \n              # Add an index.html if our file is the entry point\n              if name is entryPoint\n                index.push\n                  path: \"#{base}/index.html\"\n                  content: content\n\n              path: \"#{base}/#{name}.html\"\n              content: content\n            .concat(index)\n\nA super simple template with inline CSS.\n\n        template: (title, html) ->\n          \"\"\"\n            <html>\n            <head>\n            <title>#{title}</title>\n            <style>\n            #{style}\n            </style>\n            </head>\n            <body>\n            #{html}\n            </body>\n            </html>\n          \"\"\"",
      "type": "blob"
    },
    "main.coffee.md": {
      "path": "main.coffee.md",
      "mode": "100644",
      "content": "Like a Doctor\n=============\n\nDocument all of your literate code: files that end in `.md`.\n\nInspired by Docco. Designed for the browser environment.\n\n\nThe sections can then be rendered into an html document.\n\nExport our public api.\n\n    module.exports =\n      parse: require('./parse')\n",
      "type": "blob"
    },
    "parse.coffee.md": {
      "path": "parse.coffee.md",
      "mode": "100644",
      "content": "Parse\n=====\n\nParse a Markdown document into an array of sections that contain code and text.\n\nImplementation\n--------------\n\nRegExes for detecting indentation, blank lines, and section breaks.\n\n    indent = /^([ ]{4}|\\t)/\n    blank = /^\\s*$/\n    sectionBreak = /^(---+|===+)$/\n\nParsing converts a string of Markdown text into an array of sections.\n\n    parse = (source) ->\n\nA helper to create section objects. Each section contains text and code.\n\n      Section = ->\n        text: []\n        code: []\n\nOur array of sections that we will return.\n\n      sections = [Section()]\n\nA helper to get the last section in the array.\n\n      lastSection = ->\n        sections.last()\n\nWhenever we encounter code we push it onto the last section.\n\n      pushCode = (code) ->\n        lastSection().code.push code\n\nPushing text is a little bit more complicated. If the last section has code in\nit then we need to push a new section on and add the text to that.\n\nIf the last section is doesn't have any code yet we can push our text onto it.\n\nIf our text matches a `sectionbreak` then we push a new section after adding\nour text to the previous section.\n\n      pushText = (text) ->\n        if lastSection().code.length\n          section = Section()\n          section.text.push text\n          sections.push section\n        else\n          lastSection().text.push text\n\n          sections.push Section() if sectionBreak.test text\n\n      pushEmpty = ->\n        if lastWasCode\n          pushCode(\"\")\n        else\n          lastSection().text.push \"\"\n\n      lastWasCode = false\n\n      source.split(\"\\n\").each (line) ->\n        if blank.exec(line)\n          pushEmpty()\n        else if match = indent.exec(line)\n          lastWasCode = true\n          pushCode line[match[0].length..]\n        else\n          lastWasCode = false\n          pushText line\n\n      sections.each (section) ->       \n        section.text = truncateEmpties(section.text).join(\"\\n\")\n        section.code = truncateEmpties(section.code).join(\"\\n\")\n\n    module.exports = parse\n\nHelpers\n-------\n\nThis helper removes empty strings from the end of our text and code arrays so\nwe're not left with extra newlines and things in between sections.\n\n    truncateEmpties = (array) ->\n      while (last = array.last())? and last is \"\"\n        array.pop()\n      \n      return array\n",
      "type": "blob"
    },
    "pixie.cson": {
      "path": "pixie.cson",
      "mode": "100644",
      "content": "version: \"0.1.1\"\nremoteDependencies: [\n  \"//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js\"\n  \"http://strd6.github.io/tempest/javascripts/envweb.js\"\n  \"http://strd6.github.io/require/master.js\"\n]\n",
      "type": "blob"
    },
    "style/markdown.css": {
      "path": "style/markdown.css",
      "mode": "100644",
      "content": "body{\n    margin: 0 auto;\n    font-family: Georgia, Palatino, serif;\n    color: #444444;\n    line-height: 1;\n    max-width: 960px;\n    padding: 30px;\n}\nh1, h2, h3, h4 {\n    color: #111111;\n    font-weight: 400;\n}\nh1, h2, h3, h4, h5, p {\n    margin-bottom: 24px;\n    padding: 0;\n}\nh1 {\n    font-size: 48px;\n}\nh2 {\n    font-size: 36px;\n    /* The bottom margin is small. It's designed to be used with gray meta text\n     * below a post title. */\n    margin: 24px 0 6px;\n}\nh3 {\n    font-size: 24px;\n}\nh4 {\n    font-size: 21px;\n}\nh5 {\n    font-size: 18px;\n}\na {\n    color: #0099ff;\n    margin: 0;\n    padding: 0;\n    vertical-align: baseline;\n}\na:hover {\n    text-decoration: none;\n    color: #ff6600;\n}\na:visited {\n    color: purple;\n}\nul, ol {\n    padding: 0;\n    margin: 0;\n}\nli {\n    line-height: 24px;\n}\nli ul, li ul {\n    margin-left: 24px;\n}\np, ul, ol {\n    font-size: 16px;\n    line-height: 24px;\n    max-width: 540px;\n}\npre {\n    padding: 0px 24px;\n    max-width: 800px;\n    white-space: pre-wrap;\n}\ncode {\n    font-family: Consolas, Monaco, Andale Mono, monospace;\n    line-height: 1.5;\n    font-size: 13px;\n}\naside {\n    display: block;\n    float: right;\n    width: 390px;\n}\nblockquote {\n    border-left:.5em solid #eee;\n    padding: 0 2em;\n    margin-left:0;\n    max-width: 476px;\n}\nblockquote  cite {\n    font-size:14px;\n    line-height:20px;\n    color:#bfbfbf;\n}\nblockquote cite:before {\n    content: '\\2014 \\00A0';\n}\n\nblockquote p {  \n    color: #666;\n    max-width: 460px;\n}\nhr {\n    width: 540px;\n    text-align: left;\n    margin: 0 auto 0 0;\n    color: #999;\n}",
      "type": "blob"
    },
    "template.coffee.md": {
      "path": "template.coffee.md",
      "mode": "100644",
      "content": "\nStole the template from Docco parallel style.\n\n    template = _.template \"\"\"\n      <!DOCTYPE html>\n      \n      <html>\n      <head>\n        <title><%= title %></title>\n        <meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\">\n        <link rel=\"stylesheet\" media=\"all\" href=\"style.css\" />\n      </head>\n      <body>\n        <div id=\"container\">\n          <div id=\"background\"></div>\n          <ul class=\"sections\">\n              <% for (var i=0, l=sections.length; i<l; i++) { %>\n              <% var section = sections[i]; %>\n              <li id=\"section-<%= i + 1 %>\">\n                  <div class=\"annotation\">\n                    <div class=\"pilwrap\">\n                      <a class=\"pilcrow\" href=\"#section-<%= i + 1 %>\">&#182;</a>\n                    </div>\n                    <%= section.docsHtml %>\n                  </div>\n                  <div class=\"content\"><%= section.codeHtml %></div>\n              </li>\n              <% } %>\n          </ul>\n        </div>\n      </body>\n      </html>\n    \"\"\"\n\n    module.exports = template\n",
      "type": "blob"
    },
    "test/main.coffee": {
      "path": "test/main.coffee",
      "mode": "100644",
      "content": "md = require \"../main\"\n\ndescribe \"Parsing\", ->\n  it \"should return an array of sections\", ->\n    sections = md.parse \"\"\"\n      A sample text + code section\n\n          I'm the code\n    \"\"\"\n\n    assert sections.length is 1\n    assert sections.first().text is \"A sample text + code section\"\n    assert sections.first().code is \"I'm the code\"\n\ndescribe \"Stuff spanning multiple lines\", ->\n  it \"should be split by newline characters\", ->\n    sections = md.parse \"\"\"\n      1\n      2\n      3\n\n          Code1\n          Code2\n    \"\"\"\n\n    assert sections.length is 1\n    assert sections.first().text is \"1\\n2\\n3\"\n    assert sections.first().code is \"Code1\\nCode2\"\n\ndescribe \"A normal markdown paragraph\", ->\n  it \"should keep newlines within\", ->\n    sections = md.parse \"\"\"\n      I'm talking about stuff.\n      \n      Paragraph two is rad!\n    \"\"\"\n    \n    assert sections.first().text.match(\"\\n\\n\")\n\ndescribe \"Headers\", ->\n  it \"should split sections\", ->\n    sections = md.parse \"\"\"\n      Intro\n      -----\n      \n      Some other stuff\n    \"\"\"\n    \n    assert sections.length is 2\n\ndescribe \"Many code text sequences\", ->\n  it \"should add text in new sections after code\", ->\n    sections = md.parse \"\"\"\n      Some description\n\n          Code\n\n      Another description\n\n          More code\n\n      Hey\n    \"\"\"\n    \n    assert sections.length is 3\n",
      "type": "blob"
    },
    "test/template.coffee": {
      "path": "test/template.coffee",
      "mode": "100644",
      "content": "template = require \"../template\"\n\ndescribe \"template\", ->\n  it \"should exist\", ->\n    assert template\n\n  it \"should render html when given a title and sections\", ->\n    result = template\n      title: \"Test\"\n      sections: [\n        docsHtml: \"<h1>Hello</h1>\"\n        codeHtml: \"<pre>1 + 1 == 2</pre>\"\n      ]\n\n    assert result\n",
      "type": "blob"
    }
  },
  "distribution": {
    "documenter": {
      "path": "documenter",
      "content": "(function() {\n  var style;\n\n  style = require(\"./style/markdown\");\n\n  module.exports = function(markdownService) {\n    var documenter;\n    return documenter = {\n      document: function(source) {\n        return markdownService(source);\n      },\n      documentAll: function(pkg) {\n        var base, branch, default_branch, documentableFiles, entryPoint, promises, repository, source;\n        entryPoint = pkg.entryPoint, source = pkg.source, repository = pkg.repository;\n        branch = repository.branch, default_branch = repository.default_branch;\n        if (branch === default_branch) {\n          base = \"docs\";\n        } else {\n          base = \"\" + branch + \"/docs\";\n        }\n        documentableFiles = Object.keys(source).select(function(name) {\n          return name.extension() === \"md\";\n        });\n        promises = documentableFiles.map(function(name) {\n          return documenter.document(source[name].content);\n        });\n        return Deferred.when(promises).then(function(results) {\n          var index;\n          index = [];\n          return results.map(function(result, i) {\n            var content, name;\n            name = documentableFiles[i].withoutExtension().withoutExtension();\n            content = documenter.template(name, result.first());\n            if (name === entryPoint) {\n              index.push({\n                path: \"\" + base + \"/index.html\",\n                content: content\n              });\n            }\n            return {\n              path: \"\" + base + \"/\" + name + \".html\",\n              content: content\n            };\n          }).concat(index);\n        });\n      },\n      template: function(title, html) {\n        return \"<html>\\n<head>\\n<title>\" + title + \"</title>\\n<style>\\n\" + style + \"\\n</style>\\n</head>\\n<body>\\n\" + html + \"\\n</body>\\n</html>\";\n      }\n    };\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "main": {
      "path": "main",
      "content": "(function() {\n  module.exports = {\n    parse: require('./parse')\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "parse": {
      "path": "parse",
      "content": "(function() {\n  var blank, indent, parse, sectionBreak, truncateEmpties;\n\n  indent = /^([ ]{4}|\\t)/;\n\n  blank = /^\\s*$/;\n\n  sectionBreak = /^(---+|===+)$/;\n\n  parse = function(source) {\n    var Section, lastSection, lastWasCode, pushCode, pushEmpty, pushText, sections;\n    Section = function() {\n      return {\n        text: [],\n        code: []\n      };\n    };\n    sections = [Section()];\n    lastSection = function() {\n      return sections.last();\n    };\n    pushCode = function(code) {\n      return lastSection().code.push(code);\n    };\n    pushText = function(text) {\n      var section;\n      if (lastSection().code.length) {\n        section = Section();\n        section.text.push(text);\n        return sections.push(section);\n      } else {\n        lastSection().text.push(text);\n        if (sectionBreak.test(text)) {\n          return sections.push(Section());\n        }\n      }\n    };\n    pushEmpty = function() {\n      if (lastWasCode) {\n        return pushCode(\"\");\n      } else {\n        return lastSection().text.push(\"\");\n      }\n    };\n    lastWasCode = false;\n    source.split(\"\\n\").each(function(line) {\n      var match;\n      if (blank.exec(line)) {\n        return pushEmpty();\n      } else if (match = indent.exec(line)) {\n        lastWasCode = true;\n        return pushCode(line.slice(match[0].length));\n      } else {\n        lastWasCode = false;\n        return pushText(line);\n      }\n    });\n    return sections.each(function(section) {\n      section.text = truncateEmpties(section.text).join(\"\\n\");\n      return section.code = truncateEmpties(section.code).join(\"\\n\");\n    });\n  };\n\n  module.exports = parse;\n\n  truncateEmpties = function(array) {\n    var last;\n    while (((last = array.last()) != null) && last === \"\") {\n      array.pop();\n    }\n    return array;\n  };\n\n}).call(this);\n",
      "type": "blob"
    },
    "style/markdown": {
      "path": "style/markdown",
      "content": "module.exports = \"body{\\n    margin: 0 auto;\\n    font-family: Georgia, Palatino, serif;\\n    color: #444444;\\n    line-height: 1;\\n    max-width: 960px;\\n    padding: 30px;\\n}\\nh1, h2, h3, h4 {\\n    color: #111111;\\n    font-weight: 400;\\n}\\nh1, h2, h3, h4, h5, p {\\n    margin-bottom: 24px;\\n    padding: 0;\\n}\\nh1 {\\n    font-size: 48px;\\n}\\nh2 {\\n    font-size: 36px;\\n    /* The bottom margin is small. It's designed to be used with gray meta text\\n     * below a post title. */\\n    margin: 24px 0 6px;\\n}\\nh3 {\\n    font-size: 24px;\\n}\\nh4 {\\n    font-size: 21px;\\n}\\nh5 {\\n    font-size: 18px;\\n}\\na {\\n    color: #0099ff;\\n    margin: 0;\\n    padding: 0;\\n    vertical-align: baseline;\\n}\\na:hover {\\n    text-decoration: none;\\n    color: #ff6600;\\n}\\na:visited {\\n    color: purple;\\n}\\nul, ol {\\n    padding: 0;\\n    margin: 0;\\n}\\nli {\\n    line-height: 24px;\\n}\\nli ul, li ul {\\n    margin-left: 24px;\\n}\\np, ul, ol {\\n    font-size: 16px;\\n    line-height: 24px;\\n    max-width: 540px;\\n}\\npre {\\n    padding: 0px 24px;\\n    max-width: 800px;\\n    white-space: pre-wrap;\\n}\\ncode {\\n    font-family: Consolas, Monaco, Andale Mono, monospace;\\n    line-height: 1.5;\\n    font-size: 13px;\\n}\\naside {\\n    display: block;\\n    float: right;\\n    width: 390px;\\n}\\nblockquote {\\n    border-left:.5em solid #eee;\\n    padding: 0 2em;\\n    margin-left:0;\\n    max-width: 476px;\\n}\\nblockquote  cite {\\n    font-size:14px;\\n    line-height:20px;\\n    color:#bfbfbf;\\n}\\nblockquote cite:before {\\n    content: '\\\\2014 \\\\00A0';\\n}\\n\\nblockquote p {  \\n    color: #666;\\n    max-width: 460px;\\n}\\nhr {\\n    width: 540px;\\n    text-align: left;\\n    margin: 0 auto 0 0;\\n    color: #999;\\n}\"",
      "type": "blob"
    },
    "template": {
      "path": "template",
      "content": "(function() {\n  var template;\n\n  template = _.template(\"<!DOCTYPE html>\\n\\n<html>\\n<head>\\n  <title><%= title %></title>\\n  <meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n  <meta name=\\\"viewport\\\" content=\\\"width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\\\">\\n  <link rel=\\\"stylesheet\\\" media=\\\"all\\\" href=\\\"style.css\\\" />\\n</head>\\n<body>\\n  <div id=\\\"container\\\">\\n    <div id=\\\"background\\\"></div>\\n    <ul class=\\\"sections\\\">\\n        <% for (var i=0, l=sections.length; i<l; i++) { %>\\n        <% var section = sections[i]; %>\\n        <li id=\\\"section-<%= i + 1 %>\\\">\\n            <div class=\\\"annotation\\\">\\n              <div class=\\\"pilwrap\\\">\\n                <a class=\\\"pilcrow\\\" href=\\\"#section-<%= i + 1 %>\\\">&#182;</a>\\n              </div>\\n              <%= section.docsHtml %>\\n            </div>\\n            <div class=\\\"content\\\"><%= section.codeHtml %></div>\\n        </li>\\n        <% } %>\\n    </ul>\\n  </div>\\n</body>\\n</html>\");\n\n  module.exports = template;\n\n}).call(this);\n",
      "type": "blob"
    },
    "test/main": {
      "path": "test/main",
      "content": "(function() {\n  var md;\n\n  md = require(\"../main\");\n\n  describe(\"Parsing\", function() {\n    return it(\"should return an array of sections\", function() {\n      var sections;\n      sections = md.parse(\"A sample text + code section\\n\\n    I'm the code\");\n      assert(sections.length === 1);\n      assert(sections.first().text === \"A sample text + code section\");\n      return assert(sections.first().code === \"I'm the code\");\n    });\n  });\n\n  describe(\"Stuff spanning multiple lines\", function() {\n    return it(\"should be split by newline characters\", function() {\n      var sections;\n      sections = md.parse(\"1\\n2\\n3\\n\\n    Code1\\n    Code2\");\n      assert(sections.length === 1);\n      assert(sections.first().text === \"1\\n2\\n3\");\n      return assert(sections.first().code === \"Code1\\nCode2\");\n    });\n  });\n\n  describe(\"A normal markdown paragraph\", function() {\n    return it(\"should keep newlines within\", function() {\n      var sections;\n      sections = md.parse(\"I'm talking about stuff.\\n\\nParagraph two is rad!\");\n      return assert(sections.first().text.match(\"\\n\\n\"));\n    });\n  });\n\n  describe(\"Headers\", function() {\n    return it(\"should split sections\", function() {\n      var sections;\n      sections = md.parse(\"Intro\\n-----\\n\\nSome other stuff\");\n      return assert(sections.length === 2);\n    });\n  });\n\n  describe(\"Many code text sequences\", function() {\n    return it(\"should add text in new sections after code\", function() {\n      var sections;\n      sections = md.parse(\"Some description\\n\\n    Code\\n\\nAnother description\\n\\n    More code\\n\\nHey\");\n      return assert(sections.length === 3);\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    },
    "test/template": {
      "path": "test/template",
      "content": "(function() {\n  var template;\n\n  template = require(\"../template\");\n\n  describe(\"template\", function() {\n    it(\"should exist\", function() {\n      return assert(template);\n    });\n    return it(\"should render html when given a title and sections\", function() {\n      var result;\n      result = template({\n        title: \"Test\",\n        sections: [\n          {\n            docsHtml: \"<h1>Hello</h1>\",\n            codeHtml: \"<pre>1 + 1 == 2</pre>\"\n          }\n        ]\n      });\n      return assert(result);\n    });\n  });\n\n}).call(this);\n",
      "type": "blob"
    }
  },
  "entryPoint": "main",
  "dependencies": {},
  "remoteDependencies": [
    "//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js",
    "http://strd6.github.io/tempest/javascripts/envweb.js",
    "http://strd6.github.io/require/master.js"
  ],
  "repository": {
    "id": 13102476,
    "name": "md",
    "full_name": "STRd6/md",
    "owner": {
      "login": "STRd6",
      "id": 18894,
      "avatar_url": "https://0.gravatar.com/avatar/33117162fff8a9cf50544a604f60c045?d=https%3A%2F%2Fidenticons.github.com%2F39df222bffe39629d904e4883eabc654.png",
      "gravatar_id": "33117162fff8a9cf50544a604f60c045",
      "url": "https://api.github.com/users/STRd6",
      "html_url": "https://github.com/STRd6",
      "followers_url": "https://api.github.com/users/STRd6/followers",
      "following_url": "https://api.github.com/users/STRd6/following{/other_user}",
      "gists_url": "https://api.github.com/users/STRd6/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/STRd6/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/STRd6/subscriptions",
      "organizations_url": "https://api.github.com/users/STRd6/orgs",
      "repos_url": "https://api.github.com/users/STRd6/repos",
      "events_url": "https://api.github.com/users/STRd6/events{/privacy}",
      "received_events_url": "https://api.github.com/users/STRd6/received_events",
      "type": "User"
    },
    "private": false,
    "html_url": "https://github.com/STRd6/md",
    "description": "Generate documentation from from literate code files.",
    "fork": false,
    "url": "https://api.github.com/repos/STRd6/md",
    "forks_url": "https://api.github.com/repos/STRd6/md/forks",
    "keys_url": "https://api.github.com/repos/STRd6/md/keys{/key_id}",
    "collaborators_url": "https://api.github.com/repos/STRd6/md/collaborators{/collaborator}",
    "teams_url": "https://api.github.com/repos/STRd6/md/teams",
    "hooks_url": "https://api.github.com/repos/STRd6/md/hooks",
    "issue_events_url": "https://api.github.com/repos/STRd6/md/issues/events{/number}",
    "events_url": "https://api.github.com/repos/STRd6/md/events",
    "assignees_url": "https://api.github.com/repos/STRd6/md/assignees{/user}",
    "branches_url": "https://api.github.com/repos/STRd6/md/branches{/branch}",
    "tags_url": "https://api.github.com/repos/STRd6/md/tags",
    "blobs_url": "https://api.github.com/repos/STRd6/md/git/blobs{/sha}",
    "git_tags_url": "https://api.github.com/repos/STRd6/md/git/tags{/sha}",
    "git_refs_url": "https://api.github.com/repos/STRd6/md/git/refs{/sha}",
    "trees_url": "https://api.github.com/repos/STRd6/md/git/trees{/sha}",
    "statuses_url": "https://api.github.com/repos/STRd6/md/statuses/{sha}",
    "languages_url": "https://api.github.com/repos/STRd6/md/languages",
    "stargazers_url": "https://api.github.com/repos/STRd6/md/stargazers",
    "contributors_url": "https://api.github.com/repos/STRd6/md/contributors",
    "subscribers_url": "https://api.github.com/repos/STRd6/md/subscribers",
    "subscription_url": "https://api.github.com/repos/STRd6/md/subscription",
    "commits_url": "https://api.github.com/repos/STRd6/md/commits{/sha}",
    "git_commits_url": "https://api.github.com/repos/STRd6/md/git/commits{/sha}",
    "comments_url": "https://api.github.com/repos/STRd6/md/comments{/number}",
    "issue_comment_url": "https://api.github.com/repos/STRd6/md/issues/comments/{number}",
    "contents_url": "https://api.github.com/repos/STRd6/md/contents/{+path}",
    "compare_url": "https://api.github.com/repos/STRd6/md/compare/{base}...{head}",
    "merges_url": "https://api.github.com/repos/STRd6/md/merges",
    "archive_url": "https://api.github.com/repos/STRd6/md/{archive_format}{/ref}",
    "downloads_url": "https://api.github.com/repos/STRd6/md/downloads",
    "issues_url": "https://api.github.com/repos/STRd6/md/issues{/number}",
    "pulls_url": "https://api.github.com/repos/STRd6/md/pulls{/number}",
    "milestones_url": "https://api.github.com/repos/STRd6/md/milestones{/number}",
    "notifications_url": "https://api.github.com/repos/STRd6/md/notifications{?since,all,participating}",
    "labels_url": "https://api.github.com/repos/STRd6/md/labels{/name}",
    "created_at": "2013-09-25T18:55:25Z",
    "updated_at": "2013-09-26T23:58:31Z",
    "pushed_at": "2013-09-26T23:58:31Z",
    "git_url": "git://github.com/STRd6/md.git",
    "ssh_url": "git@github.com:STRd6/md.git",
    "clone_url": "https://github.com/STRd6/md.git",
    "svn_url": "https://github.com/STRd6/md",
    "homepage": null,
    "size": 624,
    "watchers_count": 0,
    "language": "CoffeeScript",
    "has_issues": true,
    "has_downloads": true,
    "has_wiki": true,
    "forks_count": 0,
    "mirror_url": null,
    "open_issues_count": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "master_branch": "master",
    "default_branch": "master",
    "permissions": {
      "admin": true,
      "push": true,
      "pull": true
    },
    "network_count": 0,
    "branch": "master",
    "defaultBranch": "master",
    "includedModules": [
      "Bindable"
    ]
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  }
});
</script>
</body>
</html>